package io.fritz2.lenses

import java.io.File
import javax.annotation.processing.AbstractProcessor
import javax.annotation.processing.RoundEnvironment
import javax.annotation.processing.SupportedAnnotationTypes
import javax.annotation.processing.SupportedSourceVersion
import javax.lang.model.SourceVersion
import javax.lang.model.element.TypeElement


@SupportedAnnotationTypes("io.fritz2.lenses.Lenses")
@SupportedSourceVersion(SourceVersion.RELEASE_8)
class LensesAnnotationProcessor() : AbstractProcessor() {

    override fun getSupportedAnnotationTypes(): MutableSet<String> = mutableSetOf(Lenses::class.java.name)

    override fun process(annotations: MutableSet<out TypeElement>?, roundEnv: RoundEnvironment?): Boolean {
        val annotatedElements = roundEnv?.getElementsAnnotatedWith(Lenses::class.java)
        if (annotatedElements == null || annotatedElements.isEmpty()) return false

        val kaptKotlinGeneratedDir = "src/commonGenerated/kotlin"

        File(kaptKotlinGeneratedDir, "testGenerated.kt").apply {
            parentFile.mkdirs()
            writeText("""fun hugo(): String = "peter" """)
        }

        return true
    }
}

/*
        val generatedKtFile = kotlinFile("test.generated") {
            for (element in annotatedElements) {
                val typeElement = element.toTypeElementOrNull() ?: continue

                property("simpleClassName") {
                    receiverType(typeElement.qualifiedName.toString())
                    getterExpression("this::class.java.simpleName")
                }
            }
        }

        File(kaptKotlinGeneratedDir, "testGenerated.kt").apply {
            parentFile.mkdirs()
            writeText(generatedKtFile.accept(PrettyPrinter(PrettyPrinterConfiguration())))
        }
*/
//        return true

/*
override fun process(roundEnvironment: RoundEnvironment) {

    println("###### PROCESSING #########")

    roundEnvironment.getElementsAnnotatedWith(Lenses::class.java).forEach { element ->
        when (element) {
            is Element.ClassElement -> {
                if (element.classDescriptor.isData) annotatedClasses.add(element.classDescriptor)
            }
        }
    }
}

 */


//    override fun getSupportedAnnotationTypes(): Set<String> = setOf(optics)

/*
override fun processingOver() {
    val packageName = annotatedClasses.first().containingDeclaration.fqNameSafe.asString()

    val fileSpecBuilder = FileSpec.builder(packageName, "Optics")
        .addComment("GENERATED by io.fritz2.lenses")
        .addComment("NEVER CHANGE CONTENT MANUALLY!")
        .addImport("io.fritz2.lenses", "buildLens")
        .addImport("kotlin.reflect","KProperty1")

    annotatedClasses.flatMap { buildFunctionsForClass(it) }.forEach {
        fileSpecBuilder.addFunction(it)
    }

    val kaptKotlinGeneratedDir = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME] ?: run {
        processingEnv.messager.printMessage(ERROR, "Can't find the target directory for generated Kotlin files.")
        return false
    }
    //FIXME: better way to determine source path
    val filepath = kaptKotlinGeneratedDir //+ "/" + packageName.replace('.','/'))
    println("######### " + filepath)

    fileSpecBuilder.build().writeTo(File(filepath))

}

//operator fun KProperty1<Outer, Inner>.not(): Lens<Outer, Inner> = buildLens(this) { p, v -> p.copy(inner = v)}

private fun buildFunctionsForClass(classDescriptor: ClassDescriptor): List<FunSpec> =
    classDescriptor.constructors.first().valueParameters.map {
        buildExtensionFunction(classDescriptor, it)
    }


fun createClassName(fq: FqNameUnsafe): ClassName {
    val shortName = fq.shortNameOrSpecial().toString()
    val pack = fq.asString().substringBefore(shortName).trim('.')
    return ClassName(pack,shortName)
}

private fun stringToClassName(name: String): TypeName {
    val hasParam = name.contains('<')
    val typeString = if (hasParam) name.substringBefore('<') else name

    val typeList = typeString.split(".")
    val classString = typeList.last()
    val packageString = typeList.dropLast(1).joinToString(".")
    val className = ClassName(packageString, classString)

    return if (hasParam) {
        //FIXME: handle more type parameters and nested ones
        val parameterString = name.substringAfter('<').substringBefore('>')
        className.plusParameter(stringToClassName(parameterString))
    } else {
        className
    }
}

private fun buildExtensionFunction(classDescriptor: ClassDescriptor, parameterDescriptor: ValueParameterDescriptor): FunSpec {

    val outerTypeName = stringToClassName(classDescriptor.defaultType.getJetTypeFqName(false))
    val innerTypeName = stringToClassName(parameterDescriptor.type.getJetTypeFqName(true))

    val attributeName = parameterDescriptor.name

    val receiverType = ClassName("kotlin.reflect","KProperty1")
        .plusParameter(outerTypeName)
        .plusParameter(innerTypeName)

    return FunSpec.builder("not")
        .addModifiers(KModifier.OPERATOR)
        .receiver(receiverType)
        .addStatement("return buildLens(this) {p,v -> p.copy($attributeName = v)}")
        .build()
}

}
*/
/*
import org.yanex.takenoko.*
import java.io.File
import javax.annotation.processing.*
import javax.lang.model.SourceVersion
import javax.lang.model.element.Element
import javax.lang.model.element.TypeElement
import javax.tools.Diagnostic.Kind.*

@Target(AnnotationTarget.CLASS)
annotation class TestAnnotation

@SupportedSourceVersion(SourceVersion.RELEASE_8)
@SupportedAnnotationTypes("io.fritz2.lenses.TestAnnotation")
@SupportedOptions(LensesAnnotationProcessor.KAPT_KOTLIN_GENERATED_OPTION_NAME)
class LensesAnnotationProcessor : AbstractProcessor() {
    companion object {
        const val KAPT_KOTLIN_GENERATED_OPTION_NAME = "kapt.kotlin.generated"
    }

    override fun process(annotations: MutableSet<out TypeElement>?, roundEnv: RoundEnvironment): Boolean {
        val annotatedElements = roundEnv.getElementsAnnotatedWith(TestAnnotation::class.java)
        if (annotatedElements.isEmpty()) return false

        val kaptKotlinGeneratedDir = processingEnv.options[KAPT_KOTLIN_GENERATED_OPTION_NAME] ?: run {
            processingEnv.messager.printMessage(ERROR, "Can't find the target directory for generated Kotlin files.")
            return false
        }

        val generatedKtFile = kotlinFile("test.generated") {
            for (element in annotatedElements) {
                val typeElement = element.toTypeElementOrNull() ?: continue

                property("simpleClassName") {
                    receiverType(typeElement.qualifiedName.toString())
                    getterExpression("this::class.java.simpleName")
                }
            }
        }

        File(kaptKotlinGeneratedDir, "testGenerated.kt").apply {
            parentFile.mkdirs()
            writeText(generatedKtFile.accept(PrettyPrinter(PrettyPrinterConfiguration())))
        }

        return true
    }

    fun Element.toTypeElementOrNull(): TypeElement? {
        if (this !is TypeElement) {
            processingEnv.messager.printMessage(ERROR, "Invalid element type, class expected", this)
            return null
        }

        return this
    }
}


 */